### 浏览器中的事件循环
### node 中的事件循环
在NodeJS中，事件循环是基于libuv实现，libuv是一个多平台的专注于异步IO的库
```c
// 来自 deps/uv/src/unix/core.c
while (r != 0 && loop->stop_flag == 0) {
    uv__update_time(loop);
    uv__run_timers(loop); // ⭐️ timer 小顶堆
    ran_pending = uv__run_pending(loop); // ⭐️ 上一个循环一些没来得及做完的事
    uv__run_idle(loop); // ⭐️ 底层用，暂时不懂
    uv__run_prepare(loop); // ⭐️ 底层用，暂时不懂
    uv__io_poll(loop, timeout); // ⭐️io, network or file system 等等，轮询阶段时间不能超过timer堆顶 时间
    for (r = 0; r < 8 && !uv__queue_empty(&loop->pending_queue); r++){
      uv__run_pending(loop);
    }
    uv__run_check(loop); // ⭐️ setImmediate
    uv__run_closing_handles(loop); // ⭐️ event on('close')

    if (mode == UV_RUN_ONCE) {
     // 这里不重要
    }
   
    r = uv__loop_alive(loop);
    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT){
      // 这里不重要
    }
}
```

#### timer

这部分主要是检查有没有可以执行的定时器，包括但不限于`setTimeout setInterval`。

这里的的具体实现在`deps/uv/src/unix/timer.c`，简单说就是使用一个最小堆(小顶堆), 把时间最接近的一个取出来，判断当前时间是否可以执行。

#### pending

这个阶段是执行上一个循环poll阶段还没来得及处理的callback。

这句话，在下面介绍poll阶段的时候才回过头来理解。

#### idle / prepare

底层预留

#### poll

这个阶段处理的，就是我们比较熟悉的network , fs之类的异步操作回调。就是说你去请求一个远程的接口，那么回调函数会在poll阶段执行。

然后就是跟上面pending的关联。

由于uv__io_poll代码有点长就不贴了，有兴趣自己去看。

一般来说，我们的每一个阶段，都会处理完已经就绪的所有callback，如果poll阶段触发大量的 callback，就会占用很多的时间。

我们的uv当然是不会设计成这样的，所以，它会从timer里拿到最小的(未来最快到达的)一个定时器的时间，作为poll阶段的 timeout。

如果timeout到了，还有callback没开始执行的，对不起，请到pending队列里。

可能是uv认为，poll阶段的callback，相对来说对“准时”不太敏感，所以通过这样尽量确保timer的执行不会误差太多。

#### check

这个阶段将会运行我们 setImmediate注册的回调

#### closing_handles

执行close事件注册的回调，放在循环的最后一个阶段，也是合情合理。

#### process.nextTick

process.nextTick 是独立于事件循环的任务队列

在每一个事件循环阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。

#### 